;; layer0 evaluator in scheme

;; debug
(define debug #t)
(define (toggle-debug)
  (set! debug (not debug)))
(define (print tag x)
  (if debug (begin (display tag) (display ": ") (display x) (newline) x)
      x))
(define (error reason x)
  (print "ERROR" reason)
  (print "value" x))
(define (log tag k)
  (lambda (x) (k (print tag x))))

;; util
(define false #f)
(define true 't)
(define (not1 x) (if x false true))
(define (and2 x y) (if x y false))
(define (or2 x y) (if x true y))
(define (atom x) (not (pair? x)))
(define (eq x y) (eq? x y))
(define (cadr x) (car (cdr x)))
(define (caddr x) (car (cdr (cdr x))))
(define (foldr f z xs)
  (if (atom xs) z
      (f (car xs) (foldr f z (cdr xs)))))
(define (fold2 f g xs ys)
  (if (or2 (atom xs) (atom ys)) (g xs ys)
      (f (car xs) (car ys) (fold2 f g (cdr xs) (cdr ys)))))
(define (list2 x y) (cons x (cons y ())))
(define arity1 (cons () ()))
(define arity2 (list2 () ()))
(define arity3 (cons () (list2 () ())))
(define (same-len? xs ys)
  (fold2 (lambda (x y r) r)
         (lambda (x y) (and2 (eq x ()) (eq y ())))
         xs ys))

;; subst
(define (exist x ys)
  (foldr (lambda (p r) (or2 (eq x p) r)) false ys))
(define (lookup x f ks vs)
  (fold2 (lambda (k v r)
           (if (eq k x) (f v) r))
         (lambda (k v) x) ks vs))
(define (append xs ys)
  (foldr cons ys xs))
(define (make-lambda params body)
  (cons 'lambda (list2 params body)))
(define (get-param x) (cadr x))
(define (get-body x) (caddr x))
(define (subst exp keys vals params)
  (cond ((atom exp)
         (if (exist exp params) exp
             (lookup exp (lambda (x) (list2 'quote x)) keys vals)))
        ((eq (car exp) 'quote) exp)
        ((eq (car exp) 'lambda)
         (make-lambda (get-param exp)
                      (subst (get-body exp) keys vals
                             (append (get-param exp) params))))
        (else
         (foldr (lambda (x r)
                  (cons (subst x keys vals params) r))
                () exp))))

;; eval
(define (cps/eval x k)
  (print (counter/get) x)
  (if (not (counter)) (k x)
      (cps/pre-eval
       x k
       (lambda (x)
         (cps/map
          cps/eval (print 'map/before x)
          (lambda (x)
            (cps/post-eval
             (print 'map/after x) k
             (lambda (x)
               (cps/eval x k)))))))))
(define (cps/pre-eval x skip next)
  (cps/eval-atom
   x (log 'atom skip)
   (lambda (x)
     (cps/eval-special
      x (log 'special skip)
      next))))
(define (cps/map f xs k)
  (if (atom xs) (k xs)
      (f (car xs) (lambda (hd) (cps/map f (cdr xs)
                                        (lambda (tl)
                                          (k (cons hd tl))))))))
(define (cps/post-eval x skip next)
  (if (atom (car x))
      (cps/eval-normal
       x (lambda (x) (skip (print 'normal x))))
      (cps/eval-apply
       x (lambda (x) (next (print 'apply x))))))
(define (cps/eval-atom x skip next)
  (if (atom x) (skip x) (next x)))
(define (arity-special? fn args)
  (cond ((eq fn 'quote) (same-len? args arity1))
        ((eq fn 'lambda) (same-len? args arity2))
        (else true)))
(define (cps/eval-special x skip next)
  (let ((fn (car x)) (args (cdr x)))
    (cond ((not1 (arity-special? fn args)) (error 'arity-special x))
          ((eq fn 'quote) (skip (car args)))
          ((eq fn 'lambda) (skip x))
          (else (next x)))))
(define (arity-normal? fn args)
  (cond ((eq fn 'atom) (same-len? args arity1))
        ((eq fn 'eq  ) (same-len? args arity2))
        ((eq fn 'car ) (same-len? args arity1))
        ((eq fn 'cdr ) (same-len? args arity1))
        ((eq fn 'cons) (same-len? args arity2))
        ((eq fn 'if  ) (same-len? args arity3))
        (else true)))
(define (cps/eval-normal x k)
  (let ((fn (car x)) (args (cdr x)))
    (cond
     ((not1 (arity-normal? fn args)) (error 'arity-normal x))
     ((eq fn 'atom) (k (if (atom (car args)) true ())))
     ((eq fn 'eq  ) (k (if (eq (car args) (cadr args)) true ())))
     ((eq fn 'car ) (k (if (atom (car args)) () (car (car args)))))
     ((eq fn 'cdr ) (k (if (atom (car args)) () (cdr (car args)))))
     ((eq fn 'cons) (k (cons (car args) (cadr args))))
     ((eq fn 'if  ) (k (if (eq (car args) ()) (caddr args) (cadr args))))
     (else (error 'eval-normal x)))))
(define (arity-apply? fn args)
  (if (same-len? fn arity3)
      (and2 (eq (car fn) 'lambda)
            (same-len? (get-param fn) args))
      false))
(define (cps/eval-apply x k)
  (let ((fn (car x)) (args (cdr x)))
    (if (arity-apply? fn args)
        (k (subst (get-body fn) (get-param fn) args ()))
        (error 'eval-apply x))))

;; misc
(define counter/value 0)
(define (counter/get) counter/value)
(define (counter/set n) (set! counter/value n))
(define limit/value 500)
(define (limit/get) limit/value)
(define (limit/set n) (set! limit/value n))
(define (counter)
  (let ((value (counter/get)))
    (counter/set (+ 1 value))
    (< value (limit/get))))
(define (counter/reset) (counter/set 0))
(define reverse
  '(lambda (xs)
     ((lambda (f) (f f xs ()))
      (lambda (f xs ys)
        ((if (atom xs)
             (lambda () ys)
             (lambda () (f f (cdr xs) (cons (car xs) ys)))))))))
(define numlist
  '(cons 0 (cons 1 (cons 2 (cons 3 (cons 4 ()))))))
(define (eval exp)
  (counter/reset)
  (cps/eval exp (lambda (x) x)))
(define (test-eval)
  (eval (list reverse numlist)))
